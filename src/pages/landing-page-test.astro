---
import EmptyLayout from "../layouts/EmptyLayout.astro";
import { getImage } from "astro:assets";
import heroImage from "../assets/images/hero.jpg";
import sectionImage from "../assets/images/2631991747.jpg";

// Get optimized hero image URL for background use
const optimizedHero = await getImage({
  src: heroImage,
  width: 1920,
  quality: 85,
});

// Get optimized section image
const optimizedSectionImage = await getImage({
  src: sectionImage,
  width: 1200,
  quality: 90,
});
---

<EmptyLayout title="Landing Page Test">
  <section
    id="hero-section"
    class="h-screen w-full flex flex-col justify-between p-4 md:p-8 relative overflow-hidden"
    style={`background-image: url(${optimizedHero.src}); background-size: cover; background-position: center;`}
  >
    <!-- Parallax overlay -->
    <div class="absolute inset-0 bg-black/20 pointer-events-none"></div>

    <!-- Bottom gradient overlay (bottom 20% fading out) -->
    <div
      class="absolute bottom-0 left-0 right-0 h-[50%] pointer-events-none"
      style="background: linear-gradient(to top, #3E342A 30%, transparent 100%);"
    >
    </div>

    <!-- Content with relative positioning -->
    <div class="relative z-10 w-full flex flex-col justify-between h-full">
      <!-- H1 Title - Middle Left -->
      <div class="flex items-center flex-1">
        <h1
          class="text-4xl md:text-6xl lg:text-7xl font-bold text-white drop-shadow-lg"
        >
          Voor wie niet gewoon weg wil, maar vooruit wil.
        </h1>
      </div>

      <!-- Bottom row with card and paragraph -->
      <div
        class="flex flex-col md:flex-row justify-between items-start md:items-end gap-4 md:gap-8 mt-8"
      >
        <!-- Small Card - Bottom Left -->
        <div
          class="bg-white/95 backdrop-blur-sm p-6 rounded-lg shadow-lg w-full md:max-w-xs"
        >
          <h3 class="text-lg font-semibold mb-2 text-base-800">Card Title</h3>
          <p class="text-sm text-base-600">Card content goes here</p>
        </div>

        <!-- Paragraph - Bottom Right -->
        <p class="text-white drop-shadow-md w-full md:max-w-md md:text-right">
          SOLA creÃ«ert weekenden waar beweging, wetenschap en natuur samenkomen.
          Eerlijk, helder en menselijk.
        </p>
      </div>
    </div>
  </section>

  <section
    id="second-section"
    class="min-h-[60vh] w-full grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-8 px-4 md:px-8 pt-24 md:pt-24 pb-4 md:pb-8"
    style="background-color: #3E342A;"
  >
    <!-- Left side with big paragraph -->
    <div class="flex items-center">
      <p class="text-xl md:text-2xl lg:text-4xl text-white leading-relaxed">
        Reizen die je doen thuiskomen. Met rust, beweging en eerlijke
        gesprekken, in een omgeving die helder maakt wat klopt.
      </p>
    </div>

    <!-- Right side with parallax image -->
    <div class="flex items-center justify-center">
      <img
        id="parallax-image"
        src={optimizedSectionImage.src}
        alt=""
        class="w-full max-w-[570px] object-cover object-center border-4 border-white rounded-3xl"
      />
    </div>
  </section>

  <section class="h-screen w-full"></section>
</EmptyLayout>

<script>
  // Parallax scrolling effect - background scrolls slower than content
  function initParallax() {
    const heroSection = document.getElementById("hero-section");
    if (!heroSection) return;

    let ticking = false;

    function updateParallax() {
      const rect = heroSection.getBoundingClientRect();
      const windowHeight = window.innerHeight;

      // Calculate how much of the section is visible
      const sectionTop = rect.top;
      const sectionHeight = rect.height;

      // Only apply parallax when section is in viewport
      if (sectionTop < windowHeight && sectionTop + sectionHeight > 0) {
        // Calculate scroll progress (0 when section top is at viewport top, increases as we scroll)
        const scrollProgress = -sectionTop;
        // Parallax rate: background moves slower (0.3 = 30% of scroll speed)
        const parallaxOffset = scrollProgress * 0.3;

        heroSection.style.backgroundPosition = `center ${parallaxOffset}px`;
      }

      ticking = false;
    }

    function requestTick() {
      if (!ticking) {
        window.requestAnimationFrame(updateParallax);
        ticking = true;
      }
    }

    window.addEventListener("scroll", requestTick);
    // Initial call
    updateParallax();
  }

  // Initialize on page load
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initParallax);
  } else {
    initParallax();
  }

  // Parallax effect for the section image
  function initImageParallax() {
    const parallaxImage = document.getElementById("parallax-image");
    if (!parallaxImage) return;

    let ticking = false;
    const imageContainer = parallaxImage.closest("div");
    const section = imageContainer.closest("section");
    if (!section) return;

    function updateImageParallax() {
      const sectionRect = section.getBoundingClientRect();
      const windowHeight = window.innerHeight;

      // Only apply parallax when section is in viewport
      if (sectionRect.top < windowHeight && sectionRect.bottom > 0) {
        // Calculate scroll progress relative to section position
        const scrollProgress = -sectionRect.top;
        // Parallax rate: image moves slower (0.3 = 30% of scroll speed)
        const parallaxOffset = scrollProgress * 0.3;

        parallaxImage.style.transform = `translateY(${parallaxOffset}px)`;
      }

      ticking = false;
    }

    function requestTick() {
      if (!ticking) {
        window.requestAnimationFrame(updateImageParallax);
        ticking = true;
      }
    }

    window.addEventListener("scroll", requestTick);
    // Initial call
    updateImageParallax();
  }

  // Initialize image parallax on page load
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initImageParallax);
  } else {
    initImageParallax();
  }
</script>
